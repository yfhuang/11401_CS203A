<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recursive DFS Animation (Undirected Graph)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#111826; --ink:#e7eefc; --muted:#9fb0cc; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--ink); }
    .wrap { display:grid; grid-template-columns: 440px 1fr; gap:16px; padding:16px; height:100vh; box-sizing:border-box; }
    .card { background:var(--panel); border:1px solid #1c2a44; border-radius:14px; padding:14px; box-shadow: 0 10px 25px rgba(0,0,0,.25); }
    h1 { font-size:16px; margin:0 0 8px; }
    h2 { font-size:13px; margin:14px 0 8px; color:var(--muted); font-weight:600; }
    textarea { width:100%; height:220px; resize:vertical; background:#0e1522; color:var(--ink); border:1px solid #1c2a44; border-radius:10px; padding:10px; box-sizing:border-box; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.4; }
    input, button { font:inherit; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill { padding:6px 10px; border-radius:999px; background:#0e1522; border:1px solid #1c2a44; color:var(--muted); font-size:12px; }
    .btn { background:#0e1522; color:var(--ink); border:1px solid #2a3b5f; border-radius:10px; padding:8px 10px; cursor:pointer; }
    .btn:hover { border-color:#3a5487; }
    .btn.primary { background:#13233a; border-color:#3a5487; }
    .btn.danger { border-color:#7a2c2c; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .slider { width:170px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .kv { display:grid; grid-template-columns: 120px 1fr; gap:6px 10px; font-size:12px; color:var(--muted); }
    .kv .v { color:var(--ink); }
    .status { min-height:44px; padding:10px; border-radius:10px; background:#0e1522; border:1px solid #1c2a44; font-size:12px; line-height:1.4; }
    canvas { width:100%; height:100%; background:#0b0f14; border-radius:14px; border:1px solid #1c2a44; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; font-size:12px; color:var(--muted); }
    .dot { width:10px; height:10px; border-radius:999px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .small { font-size:12px; color:var(--muted); }
    .hr { height:1px; background:#1c2a44; margin:12px 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Recursive DFS Animation (Undirected Graph)</h1>
      <div class="small">
        Deterministic rule: neighbors sorted ascending; recursion uses a call stack (shown below).
      </div>

      <h2>Graph (Adjacency List)</h2>
      <textarea id="adjInput" spellcheck="false">
0: 1 2
1: 0 3 4
2: 0 5
3: 1 6
4: 1 6
5: 2 7
6: 3 4 7
7: 5 6
      </textarea>

      <div class="row" style="margin-top:10px;">
        <span class="pill">Start</span>
        <input id="startNode" class="pill mono" style="width:90px; color:var(--ink);" value="0" />
        <button id="buildBtn" class="btn primary">Build / Reset</button>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button id="prevBtn" class="btn">◀ Prev</button>
        <button id="playBtn" class="btn primary">▶ Play</button>
        <button id="nextBtn" class="btn">Next ▶</button>
        <button id="stopBtn" class="btn danger">■ Stop</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <span class="pill">Speed</span>
        <input id="speed" class="slider" type="range" min="120" max="1200" step="40" value="420" />
        <span id="speedLabel" class="pill mono">420 ms</span>
      </div>

      <h2>Step</h2>
      <div class="kv mono">
        <div>Index</div><div class="v" id="stepIdx">0 / 0</div>
        <div>Action</div><div class="v" id="action">—</div>
        <div>Current</div><div class="v" id="current">—</div>
        <div>Call Stack</div><div class="v" id="callstack">—</div>
        <div>Visited</div><div class="v" id="visited">—</div>
      </div>

      <h2>Narration</h2>
      <div class="status mono" id="narration">Click “Build / Reset” to start.</div>

      <h2>Legend</h2>
      <div class="legend">
        <span><span class="dot" style="background:#7aa2ff;"></span>unvisited</span>
        <span><span class="dot" style="background:#ffd37a;"></span>in call stack</span>
        <span><span class="dot" style="background:#76e4a3;"></span>visited & finished</span>
        <span><span class="dot" style="background:#ff7aa2;"></span>current</span>
        <span class="small">Edges: normal (dim), tree (bright green), parent (gray), back (purple), active (orange)</span>
      </div>

      <div class="hr"></div>
      <div class="small">
        Input format: each line like <span class="mono">u: v w x</span> or <span class="mono">u v w x</span>.
        Graph is treated as <b>undirected</b> (edges added both ways).
      </div>
    </div>

    <div class="card" style="padding:12px;">
      <canvas id="cv"></canvas>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  function parseAdjacency(text) {
    const adj = new Map(); // node -> Set(neighbors)
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(s => s.length && !s.startsWith("#"));
    let maxNode = -1;

    function ensure(u) {
      if (!adj.has(u)) adj.set(u, new Set());
      maxNode = Math.max(maxNode, u);
    }

    for (const line of lines) {
      const cleaned = line.replace(/:/g, " ");
      const parts = cleaned.split(/\s+/).filter(Boolean);
      if (!parts.length) continue;

      const u = Number(parts[0]);
      if (!Number.isInteger(u) || u < 0) continue;
      ensure(u);

      for (let i = 1; i < parts.length; i++) {
        const v = Number(parts[i]);
        if (!Number.isInteger(v) || v < 0) continue;
        ensure(v);
        if (u === v) continue;
        adj.get(u).add(v);
        adj.get(v).add(u); // undirected
      }
    }

    for (let i = 0; i <= maxNode; i++) ensure(i);

    const out = {};
    for (const [u, set] of adj.entries()) {
      out[u] = Array.from(set).sort((a,b) => a - b);
    }
    return { adj: out, n: maxNode + 1 };
  }

  function edgeKey(a, b) {
    const x = Math.min(a,b), y = Math.max(a,b);
    return `${x}-${y}`;
  }

  // ---------- Recursive DFS step builder ----------
  function buildRecursiveDfsSteps(adjObj, start) {
    const nodes = Object.keys(adjObj).map(Number);
    const maxNode = nodes.length ? Math.max(...nodes) : -1;
    if (!Number.isInteger(start) || start < 0 || start > maxNode) {
      start = nodes.length ? Math.min(...nodes) : 0;
    }

    const visited = new Set();   // fully visited (finished) nodes
    const inStack = new Set();   // currently in recursive call stack
    const callStack = [];        // list, top = right
    const treeEdges = new Set(); // DFS tree edges
    const parentOf = new Map();  // node -> parent

    const steps = [];
    function snapshot({ action, current=null, activeEdge=null, note="" }) {
      steps.push({
        action,
        current,
        activeEdge, // {u,v,type} | null
        note,
        callStack: callStack.slice(),
        visited: Array.from(visited).sort((a,b)=>a-b),
        inStack: Array.from(inStack).sort((a,b)=>a-b),
        treeEdges: Array.from(treeEdges),
        parentEdges: Array.from(parentOf.entries()).map(([c,p]) => (p === null ? null : edgeKey(c,p))).filter(Boolean),
      });
    }

    function dfs(v, p) {
      parentOf.set(v, p);

      callStack.push(v);
      inStack.add(v);
      snapshot({ action: "call", current: v, note: `Call dfs(${v}${p===null ? "" : `, parent=${p}`}). Push ${v} onto call stack.` });

      // In standard DFS, "visited" usually means discovered; here we color "finished" as green,
      // and "inStack" as yellow. So we treat "finish" as when we return.
      const neigh = (adjObj[v] ?? []).slice().sort((a,b)=>a-b);

      for (const u of neigh) {
        const k = edgeKey(v,u);

        if (!inStack.has(u) && !visited.has(u)) {
          // Tree edge
          treeEdges.add(k);
          snapshot({
            action: "tree-edge",
            current: v,
            activeEdge: { u: v, v: u, type: "tree" },
            note: `Neighbor ${u} of ${v} is unvisited → take TREE edge ${v}–${u} and recurse.`
          });
          dfs(u, v);
          snapshot({
            action: "resume",
            current: v,
            activeEdge: { u: v, v: u, type: "resume" },
            note: `Return to dfs(${v}) after finishing dfs(${u}). Continue scanning neighbors of ${v}.`
          });
        } else if (u === p) {
          snapshot({
            action: "parent-edge",
            current: v,
            activeEdge: { u: v, v: u, type: "parent" },
            note: `Neighbor ${u} of ${v} is the PARENT → ignore parent edge (undirected graph).`
          });
        } else if (inStack.has(u)) {
          snapshot({
            action: "back-edge",
            current: v,
            activeEdge: { u: v, v: u, type: "back" },
            note: `Neighbor ${u} of ${v} is IN the call stack → BACK edge ${v}–${u}.`
          });
        } else {
          // visited but not in stack: cross-like in undirected DFS scanning, treat as "already finished"
          snapshot({
            action: "visited-edge",
            current: v,
            activeEdge: { u: v, v: u, type: "visited" },
            note: `Neighbor ${u} of ${v} is already finished (visited) → skip.`
          });
        }
      }

      // Finish v
      inStack.delete(v);
      visited.add(v);
      snapshot({ action: "finish", current: v, note: `All neighbors processed. Finish ${v} (mark visited & finished).` });

      callStack.pop();
      snapshot({ action: "return", current: p, note: `Return from dfs(${v}). Pop ${v} from call stack.` });
    }

    snapshot({ action: "start", current: null, note: `Start recursive DFS at node ${start}.` });
    dfs(start, null);
    snapshot({ action: "end", current: null, note: "DFS complete." });

    return { steps, start };
  }

  // ---------- Drawing ----------
  const canvas = $("cv");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function circleLayout(n, w, h) {
    const cx = w / 2, cy = h / 2;
    const r = Math.min(w, h) * 0.38;
    const pos = new Map();
    for (let i = 0; i < n; i++) {
      const ang = (Math.PI * 2 * i) / Math.max(1, n);
      pos.set(i, { x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) });
    }
    return pos;
  }

  function buildEdgeList(adjObj) {
    const edges = [];
    const seen = new Set();
    for (const [su, arr] of Object.entries(adjObj)) {
      const u = Number(su);
      for (const v of arr) {
        const k = edgeKey(u,v);
        if (seen.has(k)) continue;
        seen.add(k);
        edges.push({ u, v, k });
      }
    }
    return edges;
  }

  function draw(state, model) {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0, 0, w, h);

    const pos = model.pos;
    const edges = model.edges;

    const finished = new Set(state.visited);
    const inStack = new Set(state.inStack);
    const treeEdges = new Set(state.treeEdges);

    const current = state.current;
    const active = state.activeEdge ? edgeKey(state.activeEdge.u, state.activeEdge.v) : null;
    const activeType = state.activeEdge ? state.activeEdge.type : null;

    // Edge styling
    for (const e of edges) {
      const a = pos.get(e.u), b = pos.get(e.v);
      const isTree = treeEdges.has(e.k);
      const isActive = (active === e.k);

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);

      // Default
      ctx.strokeStyle = "#24324a";
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;

      if (isTree) {
        ctx.strokeStyle = "#76e4a3";
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.95;
      }

      // Active edge overrides
      if (isActive) {
        ctx.globalAlpha = 1.0;
        if (activeType === "parent") { ctx.strokeStyle = "#8b97ad"; ctx.lineWidth = 4; }
        else if (activeType === "back") { ctx.strokeStyle = "#b07cff"; ctx.lineWidth = 4; }
        else if (activeType === "visited") { ctx.strokeStyle = "#5f708f"; ctx.lineWidth = 4; }
        else { ctx.strokeStyle = "#ffb86b"; ctx.lineWidth = 4; } // tree/resume/etc
      }

      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }

    // Nodes
    for (let i = 0; i < model.n; i++) {
      const p = pos.get(i);
      const r = 18;

      let fill = "#7aa2ff";                 // unvisited
      if (finished.has(i)) fill = "#76e4a3"; // finished
      if (inStack.has(i)) fill = "#ffd37a";  // in call stack
      if (current === i) fill = "#ff7aa2";   // current

      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "#0b0f14";
      ctx.stroke();

      ctx.fillStyle = "#0b0f14";
      ctx.font = "bold 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(i), p.x, p.y);
    }

    ctx.fillStyle = "#9fb0cc";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Recursive DFS (undirected) — call stack shown on the left panel", 12, 12);
  }

  // ---------- UI / Playback ----------
  let model = null;
  let steps = [];
  let idx = 0;
  let timer = null;

  function setPlaying(on) {
    $("playBtn").textContent = on ? "⏸ Pause" : "▶ Play";
  }

  function render() {
    if (!steps.length || !model) return;

    const s = steps[idx];
    $("stepIdx").textContent = `${idx + 1} / ${steps.length}`;
    $("action").textContent = s.action;
    $("current").textContent = (s.current === null ? "—" : String(s.current));
    $("callstack").textContent = s.callStack.length ? `[ ${s.callStack.join(", ")} ] (top = right)` : "[]";
    $("visited").textContent = s.visited.length ? `{ ${s.visited.join(", ")} }` : "{}";
    $("narration").textContent = s.note;

    draw(s, model);

    $("prevBtn").disabled = idx <= 0;
    $("nextBtn").disabled = idx >= steps.length - 1;
  }

  function stop() {
    if (timer) clearInterval(timer);
    timer = null;
    setPlaying(false);
  }

  function playPause() {
    if (!steps.length) return;
    if (timer) { stop(); return; }
    setPlaying(true);
    const ms = Number($("speed").value);
    timer = setInterval(() => {
      if (idx >= steps.length - 1) { stop(); return; }
      idx++;
      render();
    }, ms);
  }

  function next() { if (idx < steps.length - 1) { idx++; render(); } }
  function prev() { if (idx > 0) { idx--; render(); } }

  function build() {
    stop();
    const { adj, n } = parseAdjacency($("adjInput").value);
    const start = Number($("startNode").value);

    const built = buildRecursiveDfsSteps(adj, start);
    steps = built.steps;
    idx = 0;

    resizeCanvas();
    const rect = canvas.getBoundingClientRect();
    const pos = circleLayout(n, rect.width, rect.height);
    const edges = buildEdgeList(adj);
    model = { adj, n, pos, edges };

    render();
  }

  window.addEventListener("resize", () => {
    if (!model || !steps.length) return;
    resizeCanvas();
    const rect = canvas.getBoundingClientRect();
    model.pos = circleLayout(model.n, rect.width, rect.height);
    render();
  });

  $("buildBtn").addEventListener("click", build);
  $("playBtn").addEventListener("click", playPause);
  $("stopBtn").addEventListener("click", stop);
  $("nextBtn").addEventListener("click", next);
  $("prevBtn").addEventListener("click", prev);

  $("speed").addEventListener("input", (e) => {
    $("speedLabel").textContent = `${e.target.value} ms`;
    if (timer) { stop(); playPause(); }
  });

  resizeCanvas();
})();
</script>
</body>
</html>
